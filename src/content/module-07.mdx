import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

## Trabajar en equipo como una cocina profesional

En una cocina profesional, cada cocinero trabaja en su estación. Nadie toca directamente el plato final sin que el chef lo revise primero. En desarrollo de software, funciona igual: nadie toca `main` directamente. Todo pasa por un proceso de revisión.

Este módulo te enseña el **GitHub Flow**, el flujo de trabajo que usan la mayoría de equipos profesionales.

---

### ¿Por qué no trabajar directamente en `main`?

Imagina que 5 personas pushen cambios directamente a `main` al mismo tiempo. Sería un caos:
- Nadie sabe qué cambió quién
- Si algo se rompe, no sabes quién lo rompió
- No hay revisión de calidad

Por eso existe el flujo con **Pull Requests** (PR): cada cambio pasa por una revisión antes de llegar a `main`.

---

### Dos caminos para contribuir a un proyecto

Antes de ver el flujo completo, es importante entender que existen **dos caminos** para contribuir, y cuál uses depende de tus permisos en el repositorio:

| | Como miembro del equipo | Como contribuidor externo |
|---|---|---|
| **¿Cuándo?** | Tienes permisos de escritura en el repo | No tienes permisos (proyecto open source, repo ajeno) |
| **Primer paso** | `git clone` del repo | Fork en GitHub, luego `git clone` de tu fork |
| **¿Dónde haces push?** | Directamente al repo original | A tu fork |
| **¿Cómo llegan tus cambios?** | PR dentro del mismo repo | PR desde tu fork al repo original |

En este módulo veremos primero el **camino de equipo** paso a paso. Al final verás el **camino de contribuidor externo**, que es casi idéntico: la única diferencia es que primero haces fork (lo verás en detalle en el Módulo 8) y el PR va desde tu fork al repo original.

---

### El flujo GitHub Flow

Este es el proceso completo que seguirás en tu trabajo:

1. **Crear una rama** para tu tarea
2. **Trabajar** y hacer commits en esa rama
3. **Subir la rama** a GitHub
4. **Crear un Pull Request** (pedir revisión)
5. **Revisión** y aprobación por parte del equipo
6. **Merge** en GitHub (el código entra a `main`)
7. **Actualizar** tu copia local

Veamos cada paso en detalle.

---

### Paso 1-2: Crear rama y trabajar

Esto ya lo sabes del Módulo 6:

```bash
# Crear rama para tu tarea
git switch -c feature/mi-cambio

# Hacer tu trabajo
echo "Nueva funcionalidad" > feature.txt
git add feature.txt
git commit -m "Agrega nueva funcionalidad"

# Puedes hacer más commits
echo "Más detalles" >> feature.txt
git add feature.txt
git commit -m "Agrega más detalles a la funcionalidad"
```

---

### Paso 3: Subir la rama a GitHub

Ahora que tu rama tiene commits, la subes a GitHub:

```bash
git push -u origin feature/mi-cambio
# Enumerating objects: 4, done.
# ...
# To https://github.com/tu-usuario/mi-proyecto.git
#  * [new branch]      feature/mi-cambio -> feature/mi-cambio
```

Ahora la rama existe tanto en tu computador como en GitHub.

---

### Paso 4: Crear un Pull Request (PR)

Un Pull Request es una **solicitud formal** para que tu código entre a `main`. Es como decir: "Terminé mi parte, ¿pueden revisarla antes de juntarla con el proyecto principal?"

**Cómo crear un PR desde GitHub:**

1. Ve a tu repositorio en GitHub
2. Verás un banner amarillo que dice **"Compare & pull request"** — haz clic ahí
3. (Si no aparece el banner, ve a la pestaña "Pull requests" → "New pull request")
4. **Título**: Escribe un resumen corto de lo que hiciste (ejemplo: "Agrega nueva funcionalidad de saludo")
5. **Descripción**: Explica con más detalle:
   - **Qué** cambiaste
   - **Por qué** lo cambiaste
   - Cualquier nota para los revisores
6. Haz clic en **"Create pull request"**

<Callout type="tip" title="Un buen Pull Request describe QUÉ y POR QUÉ">
  **Buen PR:** "Agrega formulario de contacto con validación de email. Se necesitaba porque los usuarios reportaban que no podían comunicarse con soporte."

  **Mal PR:** "Cambios", "Actualizaciones", "Fix"
</Callout>

---

### Paso 5: Code Review (revisión de código)

Los Pull Requests permiten que otros miembros del equipo revisen tu código antes de aceptarlo:

- **Comentarios línea por línea**: Pueden sugerir mejoras en líneas específicas
- **Aprobar**: Si todo está bien, aprueban el PR
- **Pedir cambios**: Si hay algo que mejorar, te lo piden

Si te piden cambios, simplemente haz más commits en la misma rama y sube:

```bash
# Hacer los cambios pedidos
echo "Cambio solicitado en revisión" >> feature.txt
git add feature.txt
git commit -m "Aplica cambios de la revisión de código"
git push
```

El PR se actualiza automáticamente con los nuevos commits.

---

### Paso 6: Merge en GitHub

Una vez que el PR está aprobado, es hora del **merge**. En GitHub verás un botón verde grande:

- **"Merge pull request"**: Haz clic aquí
- **"Confirm merge"**: Confirma

GitHub te dará tres opciones de merge. Entender la diferencia es importante:

| Estrategia | Qué hace | Resultado en `main` |
|-----------|----------|---------------------|
| **Squash and merge** | Combina todos tus commits en **uno solo** | Un commit limpio por tarea |
| **Create a merge commit** | Mantiene todos los commits + agrega commit de merge | Historial completo pero más ruidoso |
| **Rebase and merge** | Re-aplica cada commit sobre main (sin commit de merge) | Lineal, pero cada commit individual se mantiene |

**Nuestra recomendación: usa "Squash and merge"** como default. Cada commit en `main` debería representar una tarea completa, no 15 commits intermedios como "WIP", "fix typo", "ahora sí funciona". Con squash, tus commits de trabajo se combinan en uno limpio con el título del PR como mensaje.

```
# Sin squash (todos los commits de la rama llegan a main):
main: ... → WIP → fix typo → ahora sí → merge commit

# Con squash (un solo commit limpio):
main: ... → feat: agrega filtro de búsqueda
```

<Callout type="tip" title="¿Cuándo NO usar squash?">
  Si cada commit en tu rama es intencional y significativo (no hay WIP ni correcciones intermedias), puedes usar "Rebase and merge" para mantener esa granularidad en `main`. Pero para la mayoría de equipos, squash es el default correcto.
</Callout>

Después del merge, GitHub te dará la opción de borrar la rama remota. ¡Hazlo! Ya cumplió su propósito.

---

### Paso 7: Actualizar tu copia local

Después de que el PR se mergea en GitHub, tu copia local de `main` está desactualizada. Necesitas traer los cambios:

```bash
# Volver a main
git switch main

# Traer los cambios de GitHub
git pull
# Verás todos los cambios del merge

# Borrar la rama local (ya fue mergeada)
git branch -d feature/mi-cambio
# Deleted branch feature/mi-cambio
```

¡Listo! Tu copia local está actualizada y la rama fue limpiada.

---

### Flujo completo de ejemplo

Veamos todo el flujo de principio a fin, como lo harías en tu día a día:

```bash
# 1. Asegúrate de estar en main y actualizado
git switch main
git pull

# 2. Crear rama para tu tarea
git switch -c feature/agregar-footer

# 3. Trabajar
echo "<footer>© 2024 Mi Proyecto</footer>" > footer.html
git add footer.html
git commit -m "Agrega footer con copyright"

# 4. Subir la rama a GitHub
git push -u origin feature/agregar-footer

# 5. Ir a GitHub → crear Pull Request
#    (desde el navegador)

# 6. Esperar revisión y aprobación
#    (si te piden cambios, haz commits y push)

# 7. Merge desde GitHub (botón verde)
#    (borrar rama remota cuando GitHub lo ofrezca)

# 8. Actualizar local
git switch main
git pull
git branch -d feature/agregar-footer
```

<Callout type="info" title="Resumen del flujo profesional">

| Paso | Dónde | Comando / Acción |
|------|-------|-----------------|
| Crear rama | Terminal | `git switch -c feature/nombre` |
| Trabajar | Terminal | `git add` + `git commit` (repetir) |
| Subir rama | Terminal | `git push -u origin feature/nombre` |
| Crear PR | GitHub web | Botón "Compare & pull request" |
| Revisión | GitHub web | Comentarios, aprobación |
| Merge | GitHub web | Botón verde "Merge pull request" |
| Actualizar local | Terminal | `git switch main` + `git pull` |
| Limpieza | Terminal | `git branch -d feature/nombre` |

</Callout>

---

### Contribuir a un proyecto ajeno (via fork)

Si no tienes permisos de escritura en un repositorio (por ejemplo, un proyecto open source), el flujo es casi idéntico al de equipo, pero con un paso previo: necesitas hacer **fork** del proyecto. Un fork crea una copia del repositorio en **tu cuenta** de GitHub, donde sí tienes permisos para hacer push.

La explicación completa de fork (cómo hacerlo, cómo mantenerlo actualizado, cuándo usarlo vs clone) la verás en el **Módulo 8**. Por ahora, lo importante es entender la diferencia:

| | Como miembro del equipo | Como contribuidor externo |
|---|---|---|
| **Primer paso** | `git clone` del repo | Fork en GitHub → `git clone` de tu fork |
| **Push va a** | El repo del equipo | Tu fork |
| **PR va** | Dentro del mismo repo | Desde tu fork al repo original |

Todo lo demás (crear rama, commits, push, crear PR) es exactamente igual.

---

### GitHub CLI (`gh`) — El flujo profesional sin salir de la terminal

Hasta ahora, para crear un PR tenías que ir al navegador. **GitHub CLI** (`gh`) te permite hacer todo desde la terminal: crear PRs, revisarlos, mergearlos, gestionar issues y más.

Si todavía no instalaste `gh`, hazlo ahora (ya lo usaste para autenticarte en el Módulo 4):

```bash
# Verificar que está instalado y autenticado
gh auth status
# ✓ Logged in to github.com account tu-usuario
```

**Crear un PR desde la terminal:**

```bash
# Después de hacer push de tu rama
gh pr create --title "feat: agrega filtro de búsqueda" --body "Descripción de los cambios"

# Si prefieres que se abra un editor interactivo:
gh pr create
```

**Ver y mergear PRs:**

```bash
# Listar PRs abiertos
gh pr list

# Ver detalles del PR actual
gh pr view

# Ver los cambios (diff)
gh pr diff 1

# Mergear con squash (nuestra recomendación)
gh pr merge --squash
```

**Crear repositorios desde la terminal:**

```bash
# Crear repo público desde la carpeta actual
gh repo create mi-proyecto --public --source=. --push
# Esto reemplaza: ir a GitHub → crear repo → copiar URL → git remote add → git push
```

**Gestionar issues:**

```bash
gh issue list                    # Listar issues abiertos
gh issue create --title "..."    # Crear un issue
gh issue view 5                  # Ver un issue
gh issue close 5                 # Cerrar un issue
```

<Callout type="tip" title="Flujo profesional acelerado con gh">
  Con `gh`, el flujo completo se queda en la terminal:

  ```bash
  git switch -c feature/mi-cambio
  # ... hacer cambios, commits ...
  git push -u origin feature/mi-cambio
  gh pr create --title "feat: mi cambio" --body "Descripción"
  # ... esperar revisión ...
  gh pr merge --squash
  git switch main && git pull
  git branch -d feature/mi-cambio
  ```
</Callout>

---

### Tabla resumen de comandos

<CommandTable commands={[
  { command: "git switch -c feature/nombre", description: "Crear rama para tu tarea" },
  { command: "git push -u origin feature/nombre", description: "Subir tu rama a GitHub" },
  { command: "git push", description: "Subir nuevos commits (después del -u)" },
  { command: "git switch main", description: "Volver a la rama principal" },
  { command: "git pull", description: "Actualizar main con los cambios de GitHub" },
  { command: "git branch -d feature/nombre", description: "Borrar rama local después del merge" },
  { command: "gh pr create --title \"...\" --body \"...\"", description: "Crear un Pull Request desde la terminal" },
  { command: "gh pr list", description: "Listar Pull Requests abiertos" },
  { command: "gh pr merge --squash", description: "Mergear PR con squash" },
  { command: "gh issue list", description: "Listar issues abiertos" },
  { command: "gh repo create nombre --public --source=. --push", description: "Crear repo y subir código" },
]} />

---

### Ejercicios del módulo

**Ejercicio 1:** Asegúrate de tener un repo conectado a GitHub. Crea una rama `feature/mi-cambio` y haz un commit:

```bash
git switch -c feature/mi-cambio
echo "Este es un cambio de prueba" > cambio.txt
git add cambio.txt
git commit -m "Agrega archivo de prueba para PR"
```

**Ejercicio 2:** Sube la rama a GitHub:

```bash
git push -u origin feature/mi-cambio
```

**Ejercicio 3:** Ve a tu repositorio en GitHub y crea un Pull Request. Escribe un título descriptivo y una descripción de lo que hiciste.

**Ejercicio 4:** Mergea el PR desde GitHub (botón verde "Merge pull request" → "Confirm merge"). Si GitHub te ofrece borrar la rama, hazlo.

**Ejercicio 5:** Vuelve a tu terminal y actualiza tu copia local:

```bash
git switch main
git pull
git branch -d feature/mi-cambio
```

Verifica con `ls` que el archivo `cambio.txt` ahora está en main, y con `git branch` que la rama fue borrada.

<Callout type="tip" title="¡Felicidades, ya conoces el flujo profesional!">
  Este flujo (rama → commits → push → PR → review → merge → pull) es exactamente lo que usan equipos de desarrollo en todo el mundo. Practícalo varias veces hasta que se sienta natural. En los ejercicios finales podrás practicar un flujo completo de colaboración simulada.
</Callout>
