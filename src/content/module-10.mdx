import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

## Cómo trabajar en equipo sin destruir el proyecto

Hasta ahora has aprendido Git como herramienta individual: commits, ramas, PRs, rebase. Pero cuando trabajas en equipo, la herramienta sola no basta. Necesitas **convenciones**: reglas compartidas que evitan el caos.

Imagina una cocina de restaurante. Todos los chefs saben cocinar, pero si cada uno guarda los ingredientes donde quiere, usa los cuchillos de otro y no avisa cuándo enciende el horno, el resultado es un desastre. La solución no es mejor equipo de cocina — es tener **acuerdos sobre cómo trabajar juntos**.

Este módulo te enseña esos acuerdos para Git: cómo nombrar ramas, escribir commits, proteger `main`, crear templates de PR, y evitar los errores más comunes en equipo.

---

### Convenciones de ramas

Cuando trabajas solo, puedes nombrar tus ramas como quieras. En equipo, eso no funciona. Si una persona crea `arreglo-login`, otra `fix/login-bug` y otra `hotfix_auth`, nadie sabe qué está pasando.

**La convención estándar:**

```
tipo/descripcion-breve
```

Los tipos más comunes:

| Prefijo | Cuándo usarlo | Ejemplo |
|---------|---------------|---------|
| `feature/` | Nueva funcionalidad | `feature/filtro-busqueda` |
| `fix/` | Corrección de bug | `fix/login-timeout` |
| `hotfix/` | Arreglo urgente en producción | `hotfix/crash-pagina-inicio` |
| `docs/` | Cambios de documentación | `docs/actualizar-readme` |
| `refactor/` | Reestructurar código sin cambiar funcionalidad | `refactor/limpiar-utils` |

```bash
# Bien
git switch -c feature/carrito-compras
git switch -c fix/error-validacion-email
git switch -c docs/guia-instalacion

# Mal
git switch -c mi-rama
git switch -c cambios-pedro
git switch -c arreglo-cosa
```

**La regla de oro: una tarea = una rama.** Cada rama debe hacer una cosa específica. Si tu rama hace 5 cosas diferentes, va a ser imposible de revisar y dolorosa de mergear.

<Callout type="tip" title="¿Cómo sé que mi rama es demasiado grande?">
  Si no puedes describir tu rama en una frase corta, probablemente necesitas dividirla. "Agrega filtro de búsqueda por categoría" es buena. "Mejora varias cosas del frontend" es señal de que debes dividir en varias ramas.
</Callout>

---

### Convenciones de commits en equipo

En el Módulo 3 aprendiste **Conventional Commits** (`feat:`, `fix:`, `docs:`, etc.). En equipo, esto deja de ser una recomendación y se vuelve una **regla**: todos usan el mismo formato para que el historial sea legible y consistente.

**Recordatorio rápido del formato:**

```bash
git commit -m "feat: agrega botón de exportar a PDF"
git commit -m "fix: corrige cálculo de impuestos en factura"
git commit -m "docs: agrega sección de FAQ al README"
```

<Callout type="info" title="¿Y los commits WIP?">
  Los commits "WIP" (Work In Progress) están bien mientras trabajas en tu rama. Son tu borrador. Lo importante es que al mergear el PR con **squash merge** (como viste en el Módulo 7), todos esos commits intermedios se combinan en uno limpio. Así el historial de `main` queda impecable.
</Callout>

**Regla adicional para equipos:** si necesitas más detalle, deja una línea en blanco y escribe un cuerpo descriptivo:

```bash
git commit -m "feat: agrega autenticación con Google

Implementa OAuth 2.0 para login con Google.
Incluye botón en la página de login y manejo de
tokens en el backend."
```

---

### Branch protection en GitHub

Las convenciones de ramas y commits funcionan solo si todos las respetan. Pero, ¿qué pasa si alguien hace push directo a `main` por accidente? Para eso existen las **reglas de protección de ramas**.

Branch protection le dice a GitHub: "No dejes que nadie modifique `main` directamente. Todo debe pasar por un Pull Request".

**Cómo configurarlo:**

1. Ve a tu repositorio en GitHub
2. **Settings** → **Branches**
3. Haz clic en **Add branch ruleset** (o "Add rule" en repos más antiguos)
4. En "Branch name pattern" escribe: `main`
5. Activa estas reglas:

| Regla | Qué hace |
|-------|----------|
| **Require a pull request before merging** | Nadie puede hacer push directo a main |
| **Require approvals (1)** | Al menos una persona debe aprobar el PR |
| **Do not allow bypassing the above settings** | Ni siquiera los admins pueden saltarse las reglas |

```bash
# Con branch protection activado:

# Esto FALLA (push directo a main)
git switch main
echo "cambio directo" >> archivo.txt
git add . && git commit -m "cambio directo"
git push
# ❌ remote: error: GH006: Protected branch update failed

# Esto FUNCIONA (via PR)
git switch -c fix/mi-cambio
echo "cambio via PR" >> archivo.txt
git add . && git commit -m "fix: cambio correcto via PR"
git push -u origin fix/mi-cambio
gh pr create --title "Fix: mi cambio" --body "Descripción"
# ✅ PR creado, esperando revisión
```

<Callout type="warning" title="Branch protection es gratis para repos públicos">
  En repos privados, necesitas GitHub Team o Enterprise para configurar branch protection con todas las opciones. En repos públicos de GitHub, todas las reglas están disponibles de forma gratuita.
</Callout>

---

### PR Templates

Cuando alguien crea un Pull Request, ¿cómo sabes qué debe incluir? Un **PR template** es un archivo que GitHub usa automáticamente como plantilla cada vez que alguien crea un PR.

**Cómo crearlo:**

```bash
# Desde la raíz de tu proyecto
mkdir -p .github
```

```markdown title=".github/pull_request_template.md"
## ¿Qué hace este PR?

<!-- Describe brevemente los cambios -->

## Tipo de cambio

- [ ] Nueva funcionalidad (feature)
- [ ] Corrección de bug (fix)
- [ ] Documentación (docs)
- [ ] Refactorización (refactor)
- [ ] Otro: ___

## ¿Cómo se probó?

<!-- Describe cómo verificaste que funciona -->

## Checklist

- [ ] Mi código sigue las convenciones del proyecto
- [ ] He probado mis cambios localmente
- [ ] He actualizado la documentación si es necesario
```

```bash
# Agregar al proyecto
git add .github/pull_request_template.md
git commit -m "chore: agrega template de Pull Request"
git push
```

Ahora, cada vez que alguien crea un PR en este repositorio, verá este template ya completado con las secciones. Solo tiene que rellenar los espacios.

<Callout type="tip" title="Beneficio real del template">
  El template no es burocracia — es una **checklist que evita errores**. Sin template, los PRs suelen llegar sin descripción, sin pruebas y sin contexto. Con template, el revisor puede entender rápidamente qué hace el PR y cómo verificarlo.
</Callout>

---

### Squash merge como convención de equipo

En el Módulo 7 viste las tres estrategias de merge y recomendamos **squash merge** como default. En equipo, esto se convierte en una configuración del repositorio:

**Configurar squash como único método permitido:**
1. Settings → General → Pull Requests
2. Desmarca "Allow merge commits" y "Allow rebase merge"
3. Deja solo "Allow squash merging" marcado

Así ningún miembro del equipo puede mergear accidentalmente con otra estrategia. Todos los PRs producen un solo commit limpio en `main`.

---

### Prevenir conflictos en equipo

En el Módulo 6 aprendiste a resolver conflictos técnicamente (los marcadores `<<<<<<<`, `=======`, `>>>>>>>`). En equipo, la clave no es solo resolverlos sino **minimizarlos**:

1. **Divide el trabajo por archivos/componentes.** Si Ana trabaja en el header y Bob en el footer, no habrá conflictos.
2. **Haz pull frecuentemente.** Actualiza tu rama diariamente, no cada 3 días.
3. **Ramas pequeñas, PRs frecuentes.** Una rama de 2 días tiene menos conflictos que una de 2 semanas.
4. **Comunica antes de refactorizar.** Mover archivos o renombrar funciones genera conflictos en todas las ramas activas. Avisa al equipo.

<Callout type="warning" title="Nunca resuelvas conflictos adivinando">
  Si no entiendes qué hace el código de la otra persona, **pregunta**. Resolver un conflicto adivinando puede introducir bugs que nadie detecta hasta producción.
</Callout>

---

### Anti-patrones: lo que NO debes hacer en equipo

Estos son los errores más comunes que destruyen la productividad de un equipo. Si te reconoces en alguno, no te preocupes — todos los hemos cometido.

**1. Commits gigantes**
```bash
# MAL: un commit con 47 archivos modificados
git add .
git commit -m "muchos cambios"
# Imposible de revisar, imposible de revertir parcialmente

# BIEN: commits atómicos
git add src/auth/login.js
git commit -m "feat: agrega validación de email en login"
git add src/auth/register.js
git commit -m "feat: agrega validación de email en registro"
```

**2. Trabajar directamente en main**
```bash
# MAL
git switch main
# ... hacer cambios durante 3 días ...
git push
# Acabas de romper main para todos

# BIEN
git switch -c feature/mi-cambio
# ... trabajar tranquilo en tu rama ...
```

**3. No hacer pull antes de empezar a trabajar**
```bash
# MAL: empezar a trabajar sin actualizar
git switch -c feature/nueva
# Tu rama está basada en un main desactualizado
# Vas a tener conflictos innecesarios

# BIEN: siempre actualizar primero
git switch main
git pull
git switch -c feature/nueva
# Ahora tu rama está basada en la versión más reciente
```

**4. Acumular ramas que ya se mergearon**
```bash
# MAL: nunca limpiar
git branch
# feature/login
# feature/header
# feature/footer-v1
# feature/footer-v2
# fix/bug-viejo
# ... 30 ramas más que ya se mergearon

# BIEN: limpiar después de cada merge
git branch -d feature/mi-rama-mergeada
# O limpiar todas las ramas mergeadas de una vez
git branch --merged main | grep -v main | xargs git branch -d
```

**5. Force push a main**
```bash
# NUNCA hagas esto
git push --force origin main
# Esto REESCRIBE el historial compartido
# Todos los miembros del equipo van a tener problemas

# Force push a TU rama está OK (con cuidado)
git push --force origin feature/mi-rama
# Esto está bien si solo tú trabajas en esa rama
```

<Callout type="warning" title="¿Se puede deshacer un force push a main?">
  Técnicamente sí, con `git reflog` en el servidor. Pero en la práctica, es un incendio. Cada miembro del equipo va a tener conflictos, referencias rotas y confusión. **La regla es simple: nunca force push a ramas compartidas.**
</Callout>

---

<Callout type="tip" title="Guía rápida de decisión para equipos">
  **¿Cómo colaborar?** Si es un proyecto de tu equipo, usa clone + ramas + PR (Módulo 7). Si es un proyecto ajeno, usa fork (Módulo 8).

  **¿Cómo mergear PRs?** Configura squash merge como default (como viste arriba). Es la opción más segura y mantiene `main` limpio.
</Callout>

---

### Extra: AGENTS.md — tus convenciones para agentes de IA

Si usas agentes de IA como Claude Code o Gemini CLI (Módulo 9), cuando trabajas con ellos en un proyecto de equipo surge un problema: **el agente no conoce las convenciones de tu equipo**. Puede hacer commits con mensajes en inglés cuando tu equipo los escribe en español, o hacer push directo a `main` cuando tu equipo usa PRs.

La solución es un archivo `AGENTS.md` (o `CLAUDE.md`, dependiendo del agente) en la raíz de tu repositorio. Este archivo le dice al agente de IA las reglas del proyecto, exactamente igual que el PR template le dice a un humano cómo crear un PR.

Piénsalo así: el PR template es la "guía para humanos" y `AGENTS.md` es la "guía para IAs".

**¿Qué poner en un AGENTS.md?**

Las mismas convenciones que le explicarías a un nuevo miembro del equipo:

```markdown title="AGENTS.md"
# AGENTS.md

## Flujo de trabajo Git

Este equipo usa el flujo Feature Branch + Squash Merge.

### Reglas de Git
- Nunca hacer commit directo a main
- Crear ramas con formato: tipo/descripcion-corta
  - Tipos: feature/, fix/, docs/, refactor/
- Mensajes de commit en español, imperativo, una línea
  - Ejemplo: "Agregar filtro por región al dashboard"
- Antes de hacer push, verificar que el código corre sin errores

### Pull Requests
- Todo merge a main pasa por PR
- Usar squash merge
- Descripción del PR debe incluir: qué hace, por qué, cómo probarlo
- Borrar la rama después del merge

### Resolución de conflictos
- Al resolver conflictos, explicar qué versión se eligió y por qué
- No resolver conflictos automáticamente sin que el usuario entienda qué cambió
- Si el conflicto es ambiguo, mostrar ambas versiones y preguntar

### Convenciones del equipo
- Idioma: español para documentación, inglés para código
- Los nombres de variables y funciones en inglés
  (snake_case para R, snake_case para Python)
- Los comentarios en el código pueden ser en español
```

```bash
# Agregar al proyecto
git add AGENTS.md
git commit -m "docs: agrega AGENTS.md con convenciones para agentes IA"
git push
```

**¿Cómo funciona?**

Cuando inicias un agente de IA en tu proyecto, este lee automáticamente el archivo `AGENTS.md` (o `CLAUDE.md` en el caso de Claude Code) y sigue las instrucciones. Así:

```bash
cd mi-proyecto
claude
# Claude Code lee CLAUDE.md automáticamente

> Haz commit de mis cambios
# Sin CLAUDE.md: "Update files" (genérico, en inglés)
# Con CLAUDE.md: "Agregar filtro por región al dashboard" (sigue las convenciones)

> Crea un PR con estos cambios
# Sin CLAUDE.md: push directo a main
# Con CLAUDE.md: crea rama feature/, push, crea PR con descripción
```

<Callout type="tip" title="Cada agente tiene su archivo">
  - **Claude Code** lee `CLAUDE.md`
  - **Gemini CLI** lee `GEMINI.md`
  - **Formato genérico** que varios agentes reconocen: `AGENTS.md`

  Puedes tener los tres archivos en tu proyecto, o simplemente crear `CLAUDE.md` si tu equipo usa Claude Code. El contenido es el mismo — las convenciones de tu equipo escritas en lenguaje natural.
</Callout>

**¿Qué incluir según tu proyecto?**

| Sección | Qué poner | Ejemplo |
|---------|-----------|---------|
| Flujo de Git | Cómo hacer commits, ramas, PRs | "Usar squash merge, ramas con prefijo tipo/" |
| Idioma | En qué idioma escribir commits, docs, código | "Commits en español, código en inglés" |
| Estilo de código | Convenciones de formato y naming | "snake_case para Python, camelCase para JS" |
| Testing | Cómo correr y escribir tests | "Correr `npm test` antes de hacer commit" |
| Restricciones | Qué NO hacer | "Nunca force push a main" |

<Callout type="info" title="AGENTS.md es documentación viva">
  Al igual que el README, el archivo `AGENTS.md` debería evolucionar con tu proyecto. Cuando el equipo adopte una nueva convención, agrégala al archivo. Así, tanto humanos como agentes de IA siguen las mismas reglas — y el código se mantiene consistente.
</Callout>

---

### Tabla resumen de comandos

<CommandTable commands={[
  { command: "git switch -c feature/nombre", description: "Crear rama con convención de nombre" },
  { command: "git commit -m \"feat: descripción\"", description: "Commit con Conventional Commits" },
  { command: "git push -u origin feature/nombre", description: "Subir rama al remoto" },
  { command: "gh pr create --title \"...\" --body \"...\"", description: "Crear PR desde la terminal" },
  { command: "gh pr merge --squash", description: "Mergear PR con squash" },
  { command: "git branch --merged main | grep -v main | xargs git branch -d", description: "Eliminar ramas ya mergeadas" },
  { command: "git switch main && git pull", description: "Actualizar main antes de crear rama nueva" },
  { command: "mkdir -p .github", description: "Crear carpeta para PR template" },
]} />

---

### Ejercicios del módulo

**Ejercicio 1:** Crea un repositorio siguiendo todas las convenciones:

```bash
mkdir proyecto-equipo-10 && cd proyecto-equipo-10
git init
echo "# Proyecto con convenciones" > README.md
git add . && git commit -m "chore: inicializa proyecto"

# Crea un PR template
mkdir -p .github
echo "## ¿Qué hace este PR?" > .github/pull_request_template.md
echo "" >> .github/pull_request_template.md
echo "## Tipo de cambio" >> .github/pull_request_template.md
echo "- [ ] Feature" >> .github/pull_request_template.md
echo "- [ ] Fix" >> .github/pull_request_template.md
echo "- [ ] Docs" >> .github/pull_request_template.md
echo "" >> .github/pull_request_template.md
echo "## ¿Cómo se probó?" >> .github/pull_request_template.md

git add . && git commit -m "chore: agrega template de Pull Request"
```

**Ejercicio 2:** Practica el flujo de ramas con convenciones:

```bash
# Crea una rama con nombre correcto
git switch -c feature/agregar-estilos

# Haz commits con Conventional Commits
echo "body { margin: 0; }" > estilos.css
git add . && git commit -m "feat: agrega estilos base del proyecto"

echo "h1 { color: blue; }" >> estilos.css
git add . && git commit -m "feat: agrega estilo para títulos"

# Vuelve a main
git switch main
```

**Ejercicio 3:** Simula el flujo completo de equipo (si tienes un repo en GitHub):

```bash
# Sube el proyecto
gh repo create proyecto-equipo-10 --public --source=. --push

# Configura branch protection en Settings → Branches → Add rule
# Activa "Require a pull request before merging"

# Intenta push directo a main (debería fallar)
echo "cambio directo" >> README.md
git add . && git commit -m "test: push directo"
git push
# ❌ Debería fallar

# Hazlo correctamente via PR
git switch -c fix/actualizar-readme
git push -u origin fix/actualizar-readme
gh pr create --title "fix: actualiza README" --body "Cambio hecho correctamente via PR"
gh pr merge --squash
git switch main && git pull
```

**Ejercicio 4:** Limpia ramas mergeadas:

```bash
# Ver todas las ramas
git branch

# Eliminar ramas que ya se mergearon
git branch --merged main | grep -v main | xargs git branch -d

# Verificar que solo queda main
git branch
```

<Callout type="info" title="Convenciones = menos fricción">
  Las convenciones no son reglas arbitrarias — son acuerdos que reducen la confusión y los errores en equipo. Al principio parecen "extra", pero después de un par de semanas las haces automáticamente. Y cuando alguien nuevo se une al equipo, puede entender el proyecto rápido leyendo el historial de commits y las ramas activas.
</Callout>
