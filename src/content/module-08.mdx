import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

## Herramientas de poder para cuando ya dominas lo básico

En los módulos anteriores aprendiste a trabajar con Git de forma segura y productiva. Ahora es momento de conocer las herramientas avanzadas que te dan más control sobre la historia, la sincronización y la colaboración.

Estos comandos son más poderosos, pero también requieren más cuidado. Úsalos cuando entiendas bien lo que hacen.

---

### `git reset --hard HEAD~1` — El botón nuclear

<Callout type="warning" title="PELIGRO: Este comando DESTRUYE cambios">
  `git reset --hard` elimina el commit **Y todos los cambios en los archivos**. No hay vuelta atrás. Úsalo solo si estás 100% seguro de que quieres borrar todo.
</Callout>

```bash
# Esto BORRA el último commit y todos sus cambios
git reset --hard HEAD~1
# HEAD is now at b2c3d4e Agrega lista de ingredientes
```

Después de ejecutar esto, es como si el último commit nunca hubiera existido. Los archivos vuelven al estado del commit anterior y los cambios se pierden para siempre.

**¿Cuándo usarlo?** Casi nunca. Solo cuando hiciste algo realmente mal y estás seguro de que quieres eliminarlo por completo. En la mayoría de los casos, `git revert` (Módulo 5) es mejor opción.

| Comando | ¿Es seguro? | ¿Cuándo usarlo? |
|---------|-------------|-----------------|
| `git revert` | Sí, es la opción recomendada | Para deshacer un cambio manteniendo la historia |
| `git reset --soft` | Sí, los archivos no se pierden | Para corregir un mensaje de commit o agregar archivos olvidados |
| `git reset --hard` | **NO, destruye cambios** | Solo cuando estás 100% seguro de querer borrar todo |

---

### `git rebase` — Otra forma de integrar cambios

Merge no es la única forma de integrar cambios entre ramas. Existe otra herramienta llamada **rebase** que logra lo mismo, pero de una forma diferente.

La diferencia clave es **cómo queda la historia**:

- **Merge** crea un "nudo" en la historia: un commit especial de merge que une las dos ramas
- **Rebase** "reescribe" la historia para que sea **lineal**, como si hubieras hecho tus cambios después de todo lo que pasó en main

```
Merge: crea un commit de merge (M) que une las ramas
        main:    A --- B --- C --------- M
                              \         /
        feature:               D --- E

Rebase: mueve tus commits para que empiecen desde la punta de main
        main:    A --- B --- C --- D' --- E'
```

Con merge, la historia muestra "aquí se juntaron dos ramas". Con rebase, la historia queda limpia y lineal: tus commits aparecen como una continuación directa de `main`.

**El comando básico:**

```bash
# Estando en tu rama feature
git rebase main
```

Esto "mueve" los commits de tu rama para que empiecen desde la punta de `main`. Tus commits D y E se convierten en D' y E' (copias con el mismo contenido pero en una nueva posición de la historia).

<Callout type="warning" title="Regla de oro del rebase">
  **Nunca hagas rebase de commits que ya compartiste** (que ya subiste con `git push`). Rebase reescribe la historia, y si alguien más ya tiene esos commits, van a tener problemas para sincronizar su trabajo. Si ya hiciste push, usa merge.
</Callout>

<Callout type="tip" title="¿Merge o rebase?">
  Ambos logran lo mismo: integrar cambios de una rama a otra. **Merge** preserva la historia tal cual fue (con sus bifurcaciones y uniones). **Rebase** la simplifica (todo queda lineal). Para principiantes, merge es más seguro porque no reescribe la historia. Cuando te sientas cómodo con Git, prueba rebase — muchos equipos lo prefieren por mantener un historial más limpio.
</Callout>

---

### Mantener tu rama actualizada con rebase (en Pull Requests)

Mientras trabajas en tu rama, tus compañeros siguen mergeando cambios a `main`. Después de unos días, tu rama está **desactualizada**: le faltan cambios que ya están en `main`. Esto puede causar conflictos más difíciles cuando quieras hacer merge, y hace que tu PR sea más difícil de revisar.

La solución es **actualizar tu rama con rebase** antes de crear el PR (o durante la revisión):

```bash
# Estás en tu rama feature/mi-cambio

# 1. Traer los cambios más recientes de main
git switch main
git pull

# 2. Volver a tu rama y hacer rebase
git switch feature/mi-cambio
git rebase main

# 3. Si hay conflictos, resolverlos y continuar
# (editar archivo, resolver conflicto)
git add archivo-resuelto.txt
git rebase --continue

# 4. Si todo sale mal, puedes cancelar y volver al estado anterior
git rebase --abort
```

**¿Por qué rebase y no merge?** Si haces `git merge main` dentro de tu rama, funciona, pero cuando las historias han divergido crea commits de merge extras que ensucian la historia y hacen tu PR más difícil de revisar. Con rebase, tu rama queda como si la hubieras creado recién desde el `main` más actualizado: limpia y fácil de revisar.

---

### `git pull --rebase` — Atajo para actualizar tu rama

El flujo anterior (switch main → pull → switch feature → rebase) tiene un atajo. Si estás en tu rama y quieres actualizar directamente:

```bash
# Estando en tu rama feature/mi-cambio
git pull --rebase origin main
```

Esto hace `git fetch` + `git rebase` en un solo comando: trae los cambios de `main` del remoto y reaplica tus commits encima.

Por defecto, `git pull` sin flags hace un merge: trae los cambios remotos y crea un commit de merge para combinarlos (si las historias divergieron). La diferencia es la misma que ya conoces — `--rebase` mantiene la historia lineal, el merge por defecto preserva las bifurcaciones.

---

### `git push --force-with-lease` — Push seguro después de rebase

<Callout type="warning" title="Si ya habías hecho push antes del rebase">
  Rebase reescribe la historia de tu rama. Si ya habías subido la rama con `git push`, después del rebase necesitas forzar la subida:

  ```bash
  git push --force-with-lease
  ```

  Usamos `--force-with-lease` en vez de `--force` porque es más seguro: verifica que nadie más haya subido commits a tu rama antes de sobrescribirla. Si alguien más subió cambios, el push falla en vez de borrar su trabajo.
</Callout>

---

### Fork — Tu propia copia de un proyecto ajeno

Un **fork** es una copia completa de un repositorio de otra persona en **tu cuenta** de GitHub. Es diferente a clonar:

- **Clone**: descarga un repo a tu computador (copia local)
- **Fork**: crea una copia del repo en tu cuenta de GitHub (copia en la nube)

¿Para qué sirve? Imagina que encuentras un proyecto open source que quieres mejorar. No puedes hacer push directamente al repo de otra persona (no tienes permisos), pero puedes:

1. **Hacer fork** del proyecto (ahora tienes tu propia copia en GitHub)
2. **Clonar tu fork** a tu computador
3. Hacer tus cambios y push a **tu fork**
4. Crear un Pull Request desde tu fork al proyecto original

**Cómo hacer un fork:**

1. Ve al repositorio en GitHub que quieres copiar
2. Haz clic en el botón **"Fork"** (esquina superior derecha)
3. Selecciona tu cuenta como destino
4. ¡Listo! Ahora tienes una copia en `github.com/tu-usuario/nombre-repo`

**Trabajar con tu fork:**

```bash
# 1. Clonar TU fork (no el repo original)
git clone https://github.com/tu-usuario/nombre-repo.git
cd nombre-repo

# Verificar: origin apunta a TU fork
git remote -v
# origin  https://github.com/tu-usuario/nombre-repo.git (fetch)
# origin  https://github.com/tu-usuario/nombre-repo.git (push)

# 2. Crear una rama para tu contribución (nunca trabajes en main)
git switch -c feature/mi-mejora

# 3. Hacer tus cambios, add y commit
echo "Mi mejora" >> archivo.txt
git add archivo.txt
git commit -m "Agrega mejora al archivo"

# 4. Subir la rama a TU fork
git push -u origin feature/mi-mejora
```

Después ve a GitHub y crea un **Pull Request** desde tu fork al repositorio original. GitHub detecta automáticamente la rama que subiste y te ofrece crear el PR.

<Callout type="tip" title="Fork vs Clone: ¿cuándo usar cada uno?">
  - **Clone**: cuando quieres descargar un repo para verlo o usarlo localmente
  - **Fork**: cuando quieres hacer cambios y eventualmente proponerlos al proyecto original, o cuando quieres tu propia versión independiente de un proyecto
</Callout>

---

### Mantener tu fork actualizado con `upstream`

Con el tiempo, el proyecto original seguirá avanzando. Para traer esos cambios a tu fork:

```bash
# Agregar una conexión al repo original (se hace una sola vez)
git remote add upstream https://github.com/autor-original/nombre-repo.git

# Traer los cambios del original y actualizar tu fork
git fetch upstream
git switch main
git merge upstream/main
git push
# Ahora tu fork está al día con el proyecto original
```

`upstream` es el nombre convencional para el repositorio original (el que forkeaste). `origin` sigue siendo tu fork.

---

### `git fetch` — Preguntar si hay novedades

`git fetch` revisa si hay cambios nuevos en GitHub **sin aplicarlos** a tus archivos. Es como mirar el buzón sin abrir las cartas.

```bash
git fetch
# Si hay cambios nuevos, te muestra información
# Si no hay cambios, no muestra nada
```

Es útil para verificar si alguien más subió cambios antes de traerlos. La diferencia con `git pull`:

- `git fetch`: solo descarga la información, tus archivos no cambian
- `git pull`: descarga Y aplica los cambios (es un `fetch` + `merge`)

---

### `git pull` avanzado

Ya conoces `git pull` del Módulo 4. Aquí van los detalles más avanzados.

**El comportamiento por defecto de `git pull` es hacer merge.** Cuando ejecutas `git pull` sin flags, Git hace dos cosas automáticamente:

1. `git fetch` — descarga los cambios del remoto
2. `git merge` — fusiona esos cambios con tu rama local

Como el merge ya viene "de fábrica", **no existe un flag `--merge`**. Si intentas `git pull --merge`, Git te dará un error. Es lógico pensar que debería existir (sobre todo porque sí existe `--rebase`), pero sería redundante.

**Los flags que sí existen:**

```bash
# Pull normal (fetch + merge) — comportamiento por defecto
git pull

# Pull con rebase (fetch + rebase, historia lineal)
git pull --rebase origin main

# Forzar commit de merge explícito (incluso si no hay conflictos)
git pull --no-ff

# Forzar merge aunque tu config global diga rebase
git pull --no-rebase

# Solo funciona si no hay divergencia (el más seguro)
git pull --ff-only
```

<Callout type="tip" title="¿Cuál usar?">
  - `git pull` (sin flags): suficiente para el 90% de los casos
  - `git pull --rebase`: cuando quieres mantener la historia lineal
  - `git pull --no-rebase`: cuando configuraste rebase por defecto pero para un caso puntual quieres merge
  - `git pull --ff-only`: el más seguro — si tu historial local divergió del remoto, **falla** en vez de intentar fusionar. Así evitas commits de merge accidentales y decides tú cómo resolver la situación
  - `git pull --no-ff`: cuando quieres dejar registro explícito de que se integraron cambios externos, aunque no haya conflictos
</Callout>

<Callout type="warning" title="Siempre haz commit antes de pull">
  Antes de hacer `git pull`, asegúrate de haber hecho commit de todos tus cambios locales. Si tienes cambios sin guardar y los cambios remotos tocan los mismos archivos, podrías tener conflictos difíciles de resolver.

  ```bash
  # Antes de pull, siempre:
  git status
  # Si hay cambios pendientes:
  git add .
  git commit -m "Guarda cambios antes de pull"
  # Ahora sí:
  git pull
  ```
</Callout>

---

### Tabla resumen

<CommandTable commands={[
  { command: "git reset --hard HEAD~1", description: "⚠️ BORRAR último commit y todos sus cambios" },
  { command: "git rebase main", description: "Reescribir tu rama para que empiece desde la punta de main" },
  { command: "git rebase --continue", description: "Continuar rebase después de resolver conflicto" },
  { command: "git rebase --abort", description: "Cancelar rebase y volver al estado anterior" },
  { command: "git pull --rebase origin main", description: "Actualizar tu rama con rebase en un solo comando" },
  { command: "git push --force-with-lease", description: "Push seguro después de rebase (verifica que nadie más subió)" },
  { command: "Fork (botón en GitHub)", description: "Crear tu propia copia de un repo ajeno" },
  { command: "git remote add upstream <URL>", description: "Conectar con el repo original (después de fork)" },
  { command: "git fetch", description: "Revisar si hay cambios nuevos (sin aplicar)" },
  { command: "git fetch upstream", description: "Traer cambios del repo original (fork)" },
  { command: "git pull", description: "Descargar y aplicar cambios de GitHub (merge por defecto)" },
  { command: "git pull --ff-only", description: "Pull seguro: falla si el historial divergió" },
  { command: "git pull --no-rebase", description: "Forzar merge aunque tu config diga rebase" },
]} />

---

### Ejercicios del módulo

**Ejercicio 1:** Practica `git reset --hard` en un repo desechable:

```bash
mkdir practica-avanzado && cd practica-avanzado
git init
echo "Línea 1" > archivo.txt
git add . && git commit -m "Commit 1"
echo "Línea 2" >> archivo.txt
git add . && git commit -m "Commit 2"
echo "Línea 3" >> archivo.txt
git add . && git commit -m "Commit 3"

# Ver historial
git log --oneline
# Ahora borra el último commit
git reset --hard HEAD~1
git log --oneline
cat archivo.txt
# La línea 3 desapareció por completo
```

**Ejercicio 2:** Practica rebase entre ramas:

```bash
# Crear commits en main
echo "Base actualizada" >> archivo.txt
git add . && git commit -m "Actualiza base en main"

# Crear rama y trabajar
git switch -c feature/prueba-rebase
echo "Cambio en rama" > rama.txt
git add . && git commit -m "Agrega archivo en rama"

# Volver a main y agregar otro commit
git switch main
echo "Otro cambio en main" >> archivo.txt
git add . && git commit -m "Otro cambio en main"

# Rebase: actualizar la rama
git switch feature/prueba-rebase
git rebase main
git log --oneline
# Tu commit de rama aparece DESPUÉS de los de main

# Limpieza
git switch main
git merge feature/prueba-rebase
git branch -d feature/prueba-rebase
```

**Ejercicio 3:** Haz fork de un repositorio público: ve a cualquier repo en GitHub, haz clic en "Fork", clona **tu fork** y verifica con `git remote -v` que apunta a tu cuenta.

**Ejercicio 4:** Practica `git fetch` para ver cambios sin aplicarlos:

```bash
# En un repo conectado a GitHub
git fetch
git log --oneline origin/main
# Ves los commits remotos sin que tus archivos cambien
git pull
# Ahora sí se aplican
```

<Callout type="tip" title="Estas herramientas son poderosas pero opcionales">
  Todo lo que aprendiste en los módulos 1-7 es suficiente para trabajar profesionalmente con Git. Las técnicas de este módulo te dan más control, pero solo úsalas cuando las necesites. No compliques tu flujo si merge y pull básico te funcionan bien.
</Callout>
