import Callout from '../components/Callout.astro';
import CommandTable from '../components/CommandTable.astro';

## Git es tu red de seguridad

Si el experimento falla, siempre puedes volver atrás. Esa es la gran promesa de Git: que puedes experimentar sin miedo porque nada se pierde de verdad (siempre y cuando hagas commits).

En este módulo vas a aprender a viajar en el tiempo por tu proyecto, deshacer errores y corregir metidas de pata. Todos cometemos errores, y Git está diseñado para eso.

---

### `git log --oneline` — Repaso: tu mapa del tiempo

Antes de viajar, necesitas saber a dónde puedes ir. Cada commit tiene un **hash** único: esos 7 caracteres raros al inicio de cada línea.

```bash
git log --oneline
# d4e5f6a Agrega instrucciones de preparación
# b2c3d4e Agrega lista de ingredientes
# a1b2c3d Agrega receta inicial de pasta
```

Esos hashes (`d4e5f6a`, `b2c3d4e`, `a1b2c3d`) son como las coordenadas de cada punto en el tiempo. Los vas a usar para decirle a Git a dónde quieres ir.

---

### `git switch --detach` — Modo turista al pasado

¿Quieres ver cómo era tu proyecto hace 3 commits? `git switch --detach` te lleva ahí como un turista: puedes mirar pero no deberías cambiar nada.

```bash
# Viajar al primer commit
git switch --detach a1b2c3d
# HEAD is now at a1b2c3d Agrega receta inicial de pasta

# Ahora tu proyecto está exactamente como estaba en ese momento
cat receta.txt
# # Receta de Pasta
# (solo la primera línea, porque los ingredientes se agregaron después)
```

Piensa en esto como visitar un museo: puedes mirar todo, pero si quieres hacer cambios permanentes, deberías volver a tu rama primero.

Git te va a mostrar un mensaje que dice **"HEAD detached"**. No te asustes, es normal. Significa que estás visitando el pasado pero no estás "parado" en ninguna rama.

<Callout type="info" title="Detached HEAD: puedes mirar (y técnicamente editar), pero ten cuidado">
  Mientras estés en "detached HEAD", puedes explorar e incluso hacer commits. Pero esos commits **no pertenecen a ninguna rama**, así que si cambias de rama sin guardarlos, se perderán. Para explorar es completamente seguro. Si quieres hacer cambios permanentes, primero crea una rama con `git switch -c nombre-rama`.
</Callout>

Para volver al presente:

```bash
git switch main
# Switched to branch 'main'
# ¡De vuelta al presente! Tus archivos vuelven a su estado actual.
```

---

### `git revert` — El antídoto seguro

`git revert` es la forma **recomendada** de deshacer un cambio. Es como tachar algo con corrector en vez de arrancar la página: el error original sigue en la historia, pero creas un nuevo commit que lo deshace.

```bash
# Supongamos que el último commit agregó algo que no querías
git log --oneline
# d4e5f6a Agrega instrucciones de preparación   ← este fue un error
# b2c3d4e Agrega lista de ingredientes
# a1b2c3d Agrega receta inicial de pasta

# Revertir el último commit
git revert d4e5f6a
# Se abre tu editor para el mensaje del commit de reversión
# (guarda y cierra el editor)

# Ahora el historial tiene un commit nuevo que deshace el cambio
git log --oneline
# e5f6a7b Revert "Agrega instrucciones de preparación"
# d4e5f6a Agrega instrucciones de preparación
# b2c3d4e Agrega lista de ingredientes
# a1b2c3d Agrega receta inicial de pasta
```

¿Ves? El commit original sigue ahí (la historia no se borró), pero hay un nuevo commit que deshace sus cambios. Es la forma más limpia y segura.

<Callout type="tip" title="¿Cuándo usar revert?">
  Usa `git revert` cuando ya compartiste tu código con otras personas (lo subiste a GitHub). Es seguro porque no borra historia, solo agrega un nuevo commit que deshace el cambio.
</Callout>

---

### `git reset --soft HEAD~1` — "Oops, me equivoqué en el mensaje"

¿Hiciste un commit pero te equivocaste en el mensaje? ¿O te olvidaste de agregar un archivo? `git reset --soft` deshace el commit pero **deja tus archivos intactos** en el staging.

```bash
# Acabas de hacer un commit con un typo en el mensaje
git log --oneline
# f6a7b8c Agrega ingredentes   ← ups, "ingredentes" tiene un typo

# Deshacer el commit (los archivos quedan en staging)
git reset --soft HEAD~1

# Verificar: los archivos siguen listos para commit
git status
# Changes to be committed:
#   modified: receta.txt

# Ahora puedes hacer el commit de nuevo con el mensaje correcto
git commit -m "Agrega ingredientes"
```

¿Qué significa `HEAD~1`? Es como decir "un paso atrás desde donde estoy". `HEAD` es "donde estoy ahora" y `~1` es "menos uno".

---

### `git stash` — Guardar cambios en un cajón temporal

Imagina que estás trabajando en algo y de repente necesitas cambiar de rama urgentemente (un compañero te pide revisar algo, o descubriste un bug en `main`). Pero tus cambios actuales están a medio hacer — no quieres hacer un commit de algo incompleto.

`git stash` guarda tus cambios en un "cajón temporal" y deja tu carpeta limpia:

```bash
# Tienes cambios sin commitear
git status
# modified: archivo.txt

# Guardar los cambios en el cajón
git stash
# Saved working directory and index state WIP on main

# Ahora tu carpeta está limpia
git status
# nothing to commit, working tree clean

# Puedes cambiar de rama tranquilo
git switch otra-rama
# ... hacer lo que necesitas ...
git switch main

# Recuperar tus cambios del cajón
git stash pop
# Tus cambios están de vuelta, como si nada hubiera pasado
```

<Callout type="tip" title="¿Cuándo usar stash?">
  Úsalo cuando necesitas cambiar de rama pero tienes cambios sin commitear. Es temporal — guarda, haz lo que necesitas, y recupera con `pop`. Si no estás seguro de querer recuperarlos, usa `git stash apply` (que los recupera pero los deja también en el cajón por si acaso).
</Callout>

---

### Tabla resumen

<CommandTable commands={[
  { command: "git log --oneline", description: "Ver historial compacto con hashes" },
  { command: "git switch --detach <hash>", description: "Visitar un commit pasado (modo turista)" },
  { command: "git switch main", description: "Volver al presente" },
  { command: "git revert <hash>", description: "Deshacer un commit de forma segura (crea nuevo commit)" },
  { command: "git reset --soft HEAD~1", description: "Deshacer el último commit, archivos quedan en staging" },
  { command: "git stash", description: "Guardar cambios temporalmente en un cajón" },
  { command: "git stash pop", description: "Recuperar los cambios guardados con stash" },
]} />

| Comando | ¿Es seguro? | ¿Cuándo usarlo? |
|---------|-------------|-----------------|
| `git switch --detach` | Sí, para explorar | Para visitar el pasado (los commits que hagas aquí se pierden si no creas una rama) |
| `git revert` | Sí, es la opción recomendada | Para deshacer un cambio manteniendo la historia |
| `git reset --soft` | Sí, los archivos no se pierden | Para corregir un mensaje de commit o agregar archivos olvidados |
| `git stash` / `git stash pop` | Sí, es temporal y reversible | Para guardar cambios sin commitear cuando necesitas cambiar de rama |

---

### Ejercicios del módulo

**Ejercicio 1:** Crea un repo de práctica con 3 commits (uno por cada cambio en un archivo):

```bash
mkdir practica-tiempo && cd practica-tiempo
git init
echo "Línea 1: Hola" > archivo.txt
git add . && git commit -m "feat: agrega línea 1"
echo "Línea 2: Mundo" >> archivo.txt
git add . && git commit -m "feat: agrega línea 2"
echo "Línea 3: Git es genial" >> archivo.txt
git add . && git commit -m "feat: agrega línea 3"
```

**Ejercicio 2:** Usa `git log --oneline` para ver el historial. Deberías ver 3 commits con sus hashes.

**Ejercicio 3:** Viaja al primer commit con `git switch --detach <hash>` (usa el hash de tu primer commit). Mira el contenido del archivo con `cat archivo.txt`. ¿Solo tiene la línea 1? Vuelve al presente con `git switch main`.

**Ejercicio 4:** Usa `git revert` para deshacer el último commit. Revisa con `git log --oneline` que se creó un nuevo commit de reversión. Verifica con `cat archivo.txt` que la línea 3 desapareció.

**Ejercicio 5:** Haz un commit nuevo y luego deshazlo con `git reset --soft HEAD~1`. Verifica con `git status` que los archivos siguen en staging (en verde).

```bash
echo "Línea extra de prueba" >> archivo.txt
git add . && git commit -m "feat: agrega línea extra"
git reset --soft HEAD~1
git status
# Deberías ver los cambios en staging (verde)
```

<Callout type="tip" title="¡No te preocupes si te equivocas!">
  Estos ejercicios son para experimentar. Si algo sale mal, simplemente borra la carpeta (`cd .. && rm -rf practica-tiempo`) y empieza de nuevo. Esa es la belleza de los repos de práctica: puedes destruirlos sin consecuencias.
</Callout>
